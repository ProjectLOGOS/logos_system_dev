"""
Banach-Tarski Knowledge Replicator

Implements paradoxical decomposition for knowledge representation and replication
within the THŌNOC fractal omniscience engine.

Dependencies: numpy, scipy
"""

import numpy as np
from scipy.spatial.transform import Rotation
from typing import Dict, List, Tuple, Set, Optional, Union, Callable
import math

class OntologicalPoint:
    """Represents a point in ontological space with trinity dimensions."""
    
    def __init__(self, existence: float, goodness: float, truth: float):
        """Initialize ontological point with trinity dimensions.
        
        Args:
            existence: 𝔼 dimension value (0-1)
            goodness: 𝔾 dimension value (0-1)
            truth: 𝕋 dimension value (0-1)
        """
        self.existence = existence
        self.goodness = goodness
        self.truth = truth
        self.vector = np.array([existence, goodness, truth])
        
    def to_complex(self) -> complex:
        """Convert to complex number for Mandelbrot mapping."""
        return complex(self.existence * self.truth, self.goodness)
    
    def to_quaternion(self) -> np.ndarray:
        """Convert to quaternion for paradoxical decomposition."""
        # Normalize vector
        norm = np.linalg.norm(self.vector)
        if norm == 0:
            return np.array([1.0, 0.0, 0.0, 0.0])
        
        normalized = self.vector / norm
        
        # Convert to quaternion (w, x, y, z)
        # Using existence for rotation angle
        angle = self.existence * math.pi
        axis = np.array([self.truth, self.goodness, self.existence])
        axis_norm = np.linalg.norm(axis)
        
        if axis_norm == 0:
            return np.array([1.0, 0.0, 0.0, 0.0])
        
        axis = axis / axis_norm
        
        quat = np.zeros(4)
        quat[0] = math.cos(angle/2)
        quat[1:4] = axis * math.sin(angle/2)
        
        return quat

class BanachTarskiReplicator:
    """Implements paradoxical decomposition for knowledge replication."""
    
    def __init__(self):
        """Initialize the Banach-Tarski replicator."""
        # Free group generators for paradoxical decomposition
        # These are the rotations that allow for the paradoxical decomposition
        self.generators = {
            'a': Rotation.from_rotvec(np.array([1, 0, 0]) * (2*np.pi/5)),
            'b': Rotation.from_rotvec(np.array([0, 1, 0]) * (2*np.pi/3)),
            'A': Rotation.from_rotvec(np.array([-1, 0, 0]) * (2*np.pi/5)),
            'B': Rotation.from_rotvec(np.array([0, -1, 0]) * (2*np.pi/3))
        }
        
        # Define partition schemes
        self.partitions = self._initialize_partitions()
        
        # Knowledge sphere state
        self.knowledge_points = {}
        
    def _initialize_partitions(self) -> Dict:
        """Initialize the partition schemes for Banach-Tarski decomposition."""
        return {
            'classic': {
                'P1': {'a', 'b'},     # First piece word patterns
                'P2': {'A', 'B'},     # Second piece word patterns
                'P3': {'aB', 'Ab'},   # Third piece word patterns
                'P4': {'AB', 'ab'},   # Fourth piece word patterns
                'P5': {'e'}           # Fixed point (empty word)
            },
            'trinity': {
                'Father': {'a', 'b'},          # Existence dimension
                'Son': {'A', 'B', 'aB', 'Ab'}, # Goodness dimension
                'Spirit': {'AB', 'ab', 'e'}    # Truth dimension
            }
        }
    
    def decompose(self, knowledge_point: OntologicalPoint, scheme: str = 'trinity') -> Dict:
        """Decompose a knowledge point into paradoxical pieces.
        
        Args:
            knowledge_point: Point in ontological space to decompose
            scheme: Partition scheme to use ('classic' or 'trinity')
            
        Returns:
            Dictionary of pieces from decomposition
        """
        # Convert to quaternion for rotations
        q = knowledge_point.to_quaternion()
        
        # Get partition scheme
        partition = self.partitions.get(scheme, self.partitions['classic'])
        
        # Create pieces
        pieces = {}
        for piece_name, word_patterns in partition.items():
            piece_points = []
            
            for pattern in word_patterns:
                # Apply rotation sequence
                rotated_q = self._apply_word_rotation(q, pattern)
                
                # Convert back to ontological point
                rotated_point = self._quaternion_to_ontological(rotated_q)
                piece_points.append(rotated_point)
            
            pieces[piece_name] = piece_points
            
        return pieces
    
    def replicate(self, pieces: Dict[str, List[OntologicalPoint]], copies: int = 2) -> List[Dict[str, List[OntologicalPoint]]]:
        """Replicate the pieces into multiple copies through reassembly.
        
        Args:
            pieces: Decomposed pieces of knowledge point
            copies: Number of copies to create (usually 2)
            
        Returns:
            List of reassembled copies
        """
        # Create copies
        replicated = []
        
        for i in range(copies):
            angle = (i / copies) * 2 * math.pi
            rotation = Rotation.from_rotvec(np.array([0, 0, 1]) * angle)
            
            copy_pieces = {}
            for piece_name, points in pieces.items():
                rotated_points = []
                for point in points:
                    q = point.to_quaternion()
                    rotated_q = rotation.apply(q[1:4])
                    # Preserve w component
                    full_q = np.array([q[0], rotated_q[0], rotated_q[1], rotated_q[2]])
                    rotated_point = self._quaternion_to_ontological(full_q)
                    rotated_points.append(rotated_point)
                
                copy_pieces[piece_name] = rotated_points
            
            replicated.append(copy_pieces)
            
        return replicated
    
    def _apply_word_rotation(self, q: np.ndarray, word: str) -> np.ndarray:
        """Apply a sequence of rotations to a quaternion."""
        if word == 'e':  # Empty word, identity rotation
            return q
        
        result = q.copy()
        for letter in word:
            rotation = self.generators[letter]
            # Only rotate the vector part (x,y,z), preserving w
            vector_part = rotation.apply(result[1:4])
            result[1:4] = vector_part
            
        return result
    
    def _quaternion_to_ontological(self, q: np.ndarray) -> OntologicalPoint:
        """Convert quaternion back to ontological point."""
        # Extract rotation angle and axis
        angle = 2 * math.acos(np.clip(q[0], -1.0, 1.0))
        
        # Avoid division by zero
        if math.sin(angle/2) == 0:
            axis = np.array([1.0, 0.0, 0.0])
        else:
            axis = q[1:4] / math.sin(angle/2)
            
        # Map back to trinity dimensions (simplified mapping)
        existence = angle / math.pi
        goodness = axis[1]
        truth = axis[0]
        
        return OntologicalPoint(existence, goodness, truth)
    
    def add_knowledge(self, point_id: str, point: OntologicalPoint) -> None:
        """Add a knowledge point to the sphere."""
        self.knowledge_points[point_id] = point
    
    def get_knowledge(self, point_id: str) -> Optional[OntologicalPoint]:
        """Retrieve a knowledge point from the sphere."""
        return self.knowledge_points.get(point_id)
    
    def replicate_all_knowledge(self, scheme: str = 'trinity') -> Dict[str, List[OntologicalPoint]]:
        """Replicate all knowledge points in the sphere."""
        all_pieces = {}
        
        for point_id, point in self.knowledge_points.items():
            pieces = self.decompose(point, scheme)
            for piece_name, piece_points in pieces.items():
                if piece_name not in all_pieces:
                    all_pieces[piece_name] = []
                all_pieces[piece_name].extend(piece_points)
        
        return all_pieces


class OntologicalSphere:
    """Represents a sphere of knowledge in ontological space."""
    
    def __init__(self):
        """Initialize the ontological sphere."""
        self.replicator = BanachTarskiReplicator()
        self.points = {}
        
    def add_point(self, name: str, existence: float, goodness: float, truth: float) -> None:
        """Add a point to the ontological sphere.
        
        Args:
            name: Identifier for the point
            existence: 𝔼 dimension value
            goodness: 𝔾 dimension value
            truth: 𝕋 dimension value
        """
        point = OntologicalPoint(existence, goodness, truth)
        self.points[name] = point
        self.replicator.add_knowledge(name, point)
    
    def paradoxical_expansion(self, scheme: str = 'trinity') -> Dict[str, int]:
        """Perform paradoxical expansion of the knowledge sphere.
        
        Args:
            scheme: Decomposition scheme to use
            
        Returns:
            Statistics about the expansion
        """
        # Start with initial count
        initial_count = len(self.points)
        
        # Decompose all points
        pieces = self.replicator.replicate_all_knowledge(scheme)
        
        # Create two copies
        copies = self.replicator.replicate(pieces, 2)
        
        # Add new points from copies
        for i, copy in enumerate(copies):
            for piece_name, points in copy.items():
                for j, point in enumerate(points):
                    point_name = f"{piece_name}_copy{i}_{j}"
                    self.points[point_name] = point
        
        # Return statistics
        final_count = len(self.points)
        return {
            "initial_count": initial_count,
            "final_count": final_count,
            "expansion_factor": final_count / initial_count if initial_count > 0 else 0
        }
    
    def find_nearest_points(self, query: OntologicalPoint, n: int = 5) -> List[Tuple[str, float]]:
        """Find the nearest points to a query in trinity space.
        
        Args:
            query: Query point
            n: Number of nearest neighbors to return
            
        Returns:
            List of (point_name, distance) tuples
        """
        distances = []
        
        for name, point in self.points.items():
            dist = np.linalg.norm(query.vector - point.vector)
            distances.append((name, dist))
        
        # Sort by distance and return top n
        return sorted(distances, key=lambda x: x[1])[:n]


# Example usage
if __name__ == "__main__":
    # Create ontological sphere
    sphere = OntologicalSphere()
    
    # Add some points representing theological concepts
    sphere.add_point("Trinity", 1.0, 1.0, 1.0)
    sphere.add_point("Creation", 0.9, 0.8, 0.95)
    sphere.add_point("Incarnation", 0.95, 1.0, 0.9)
    sphere.add_point("Resurrection", 0.8, 0.9, 1.0)
    
    # Perform paradoxical expansion
    stats = sphere.paradoxical_expansion()
    print(f"Expansion statistics: {stats}")
    
    # Query for similar concepts
    query = OntologicalPoint(0.9, 0.95, 0.9)
    nearest = sphere.find_nearest_points(query)
    print("Nearest concepts:")
    for name, distance in nearest:
        print(f"  {name}: {distance:.3f}")